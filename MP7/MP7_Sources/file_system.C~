/*
     File        : file_system.C

     Author      : Riccardo Bettati
     Modified    : 2017/05/01

     Description : Implementation of simple File System class.
                   Has support for numerical file identifiers.
 */

/*--------------------------------------------------------------------------*/
/* DEFINES */
/*--------------------------------------------------------------------------*/

    /* -- (none) -- */

/*--------------------------------------------------------------------------*/
/* INCLUDES */
/*--------------------------------------------------------------------------*/

#include "assert.H"
#include "console.H"
#include "file_system.H"

class File;
unsigned int FileSystem::size;
/*--------------------------------------------------------------------------*/
/* CONSTRUCTOR */
/*--------------------------------------------------------------------------*/

FileSystem::FileSystem() {
    Console::puts("In file system constructor.\n");
    //assert(false);
	disk = NULL;
	len_blk = 0;
}

/*--------------------------------------------------------------------------*/
/* FILE SYSTEM FUNCTIONS */
/*--------------------------------------------------------------------------*/

bool FileSystem::Mount(SimpleDisk * _disk) {
    Console::puts("mounting file system form disk\n");
    //assert(false);
	disk = _disk;
	len_blk = (size/512);
	for (int i=0;i<len_list;i++){
		files_list[i].key = -1;
		files_list[i].id = -1;
	}
	total_file_cnt = 0;
	tail_file_idx = -1;
	//Some preparation works to initialize the variables.
	memset(blk_list,0,512);
	Console::puts("Successfully mounting file system.\n");
	return true;
}

bool FileSystem::Format(SimpleDisk * _disk, unsigned int _size) {
    Console::puts("formatting disk\n");
    //assert(false);
	char temp_buffer[512];
	memset(temp_buffer, 0, 512);
	for(int i=0; i<512;i++){
		_disk->write(i, (unsigned char*)temp_buffer);
	}
	FileSystem::size = _size;
	//Also some preparation work to format the disk.
	Console::puts("Successfully formatting the disk.\n");
	return true;
	
}

File * FileSystem::LookupFile(int _file_id) {
    Console::puts("looking up file\n");
    //assert(false);
	//for each file in the inode list
	for(int i=0; i<len_list;i++){
		int cur_id = files_list[i].id;
		int cur_key = files_list[i].key;
		//If we find that current file is our target.
		if(cur_id == _file_id){
			//Read the information of it through read function and return it.
			unsigned char temp_buffer[512];
			disk->read(cur_key, temp_buffer);
			File* res = (File*) new File((inode*)temp_buffer);
			Console::puts("Find the file.\n");
			return res;
		}
	}
	//If not, we shall return failure info.
	Console::puts("Didn't find the file.\n");
	return NULL;

}

bool FileSystem::CreateFile(int _file_id) {
    Console::puts("creating file\n");
    //assert(false);
	//If we find the given id existed, then return failure infos.
	if(LookupFile(_file_id)){
		Console::puts("File already existed.\n");
		return false;
	}
	//Create a new empty inode in the next valid block position and occupy there.
	int new_head = next_valid();
	unsigned char temp_buffer[512];
	inode* next_inode = (inode*)temp_buffer;
	next_inode->key = new_head;
	next_inode->len = 0;
	occupy(new_head);
	disk->write(new_head, temp_buffer);
	//Increment the tail index by 1
	tail_file_idx += 1;
	//If exceed, overwritting the old ones.
	if(tail_file_idx >= len_list){
		Console::puts("Reach the maximum, begin overwriting.\n");
		tail_file_idx = tail_file_idx%len_list;
	}
	//Updated the inode information.
	files_list[tail_file_idx].key = new_head;
	files_list[tail_file_idx].id = _file_id;
	total_file_cnt += 1;
	Console::puts("Successfully created the file.\n");
	return true;
	
	
}

bool FileSystem::DeleteFile(int _file_id) {
    Console::puts("deleting file\n");
    //assert(false);
	//If there is no file has the given file id, return failure.
	if(not LookupFile(_file_id)){
		Console::puts("File didn't exist.\n");
		return false;
	}
	File* target_file = LookupFile(_file_id);
	int rel_key = target_file->cur_inode->key;
	//release all the block space that this file occupied.
	for(int i=0; i<target_file->cur_inode->len;i++){
		release(target_file->cur_inode->loc[i]);
	}
	//Release the inode space of the given file.
	release(rel_key);
	for(int i = 0; i<len_list;i++){
		int cur_id = files_list[i].id;
		if(cur_id == _file_id){
			files_list[i].id = -1;
			files_list[i].key = -1;
		}
	}
	total_file_cnt -= 1;
	if(total_file_cnt == 0){
		tail_file_idx = -1;
	}
	Console::puts("Successfully deleted the file.\n");
	return true;
}

void FileSystem::occupy(unsigned int begin_idx){
	blk_list[begin_idx/8] |= (1<<(begin_idx%8));
}
void FileSystem::release(unsigned int begin_idx){
	blk_list[begin_idx/8] &= ~(1<<(begin_idx%8));
}
int FileSystem::next_valid(){
	//Traverse all the blocks and for each block to find the next valid one.
	for(int i = 0; i<(len_blk/8); i++){
		for(int j=0; j<8; j++){
			if((blk_list[i] & (1<<j)) == 0){
				return(8*i+j);
			}
		}
	}
	return -1;
}
