/*
 File: scheduler.C
 
 Author:
 Date  :
 
 */

/*--------------------------------------------------------------------------*/
/* DEFINES */
/*--------------------------------------------------------------------------*/

/* -- (none) -- */

/*--------------------------------------------------------------------------*/
/* INCLUDES */
/*--------------------------------------------------------------------------*/

#include "scheduler.H"
#include "thread.H"
#include "console.H"
#include "utils.H"
#include "assert.H"
#include "simple_keyboard.H"
#include "machine.H"

/*--------------------------------------------------------------------------*/
/* DATA STRUCTURES */
/*--------------------------------------------------------------------------*/

FIFOQ::FIFOQ(FIFOQ& n){
    thread = n.thread;
    next = n.next;
  }

FIFOQ::FIFOQ(Thread* t){
    thread = t;
    next = NULL;
  }

FIFOQ::FIFOQ(){
    thread = NULL;
    next = NULL;
  }
void FIFOQ::setNext(FIFOQ* input_thread){
    next = input_thread;
  }
Thread* FIFOQ::getThread(){
	return thread;
	}

FIFOQ* FIFOQ::getNext(){
	return next;	
}
void FIFOQ::addTail(Thread* input_thread){
	//No thread in current ready queue
	if(thread == NULL && next == NULL){
		thread = input_thread;
	//We already arrived the ready quque tail
	}else if(thread != NULL && next == NULL){
		next = new FIFOQ(input_thread);
	//We haven't arrived the ready queue tail	
	}else{
		next->addTail(input_thread);
	}
    
 }
Thread* FIFOQ::popHead(){
	Thread* res = NULL;
	//There is only one thread in the ready queue
	if(thread != NULL && next == NULL){
		res = thread;
		thread = NULL;
	//more than one thread in the ready queue
	}else if(thread !=NULL && next != NULL){
		//store the head thread in the ready
		res = thread;
		thread = next->thread;
		//set the head thread as the second thread
		FIFOQ* nextFIFOQ = next;
		//set the head thread's next pointer to the third one
		next = nextFIFOQ->next;
		//remove the second thread
		delete nextFIFOQ;
	}
	return res;

}

/*--------------------------------------------------------------------------*/
/* CONSTANTS */
/*--------------------------------------------------------------------------*/

/* -- (none) -- */

/*--------------------------------------------------------------------------*/
/* FORWARDS */
/*--------------------------------------------------------------------------*/

/* -- (none) -- */

/*--------------------------------------------------------------------------*/
/* METHODS FOR CLASS   S c h e d u l e r  */
/*--------------------------------------------------------------------------*/

Scheduler::Scheduler() {

  FIFOQ ready_queue;
  unsigned int len_queue = 0;
  Console::puts("Constructed Scheduler.\n");
}


//
void Scheduler::yield() {


	Machine::disable_interrupts();
	
  
  	if (len_queue > 0){
  		Thread* popedThread = ready_queue.popHead();
  		Thread::dispatch_to(popedThread);
		len_queue--;
  	}

  	Machine::enable_interrupts();

  	Console::puts("Successfully yielded. \n");
}


//
void Scheduler::resume(Thread * _thread) {


	Machine::disable_interrupts();
	
  
	ready_queue.addTail(_thread);
	len_queue++;

	Machine::enable_interrupts();

	Console::puts("Successfully resumed. \n");

}

//
void Scheduler::add(Thread * _thread) {
  
  	ready_queue.addTail(_thread);
	len_queue++;

	Console::puts("Successfully added. \n");

}


//
void Scheduler::terminate(Thread * _thread) {
	
	FIFOQ *nextThread = NULL;
	FIFOQ *currentThread = &ready_queue;
	//traverse all the threads in the ready queue
	Thread* currentT = currentThread->getThread();
	if(currentT->ThreadId() == _thread->ThreadId()){
		Machine::disable_interrupts();
		currentThread->popHead();
	}
	while(currentThread->getNext() != NULL){
		nextThread = currentThread->getNext();
		Thread* nextT = nextThread->getThread();
		//if the next thread is our target thread
		if (nextT->ThreadId() == _thread->ThreadId()){
			//repeat what we have done in the popHead to 
			Machine::disable_interrupts();
			currentThread->setNext(nextThread->getNext());
			len_queue -= 1;
			break;
		}else{
			currentThread = nextThread;
		}
	}
	Machine::enable_interrupts(); 

	Console::puts("Successfully terminated. \n");

}

